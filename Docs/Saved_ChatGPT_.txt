Calculating FIRST and FOLLOW sets for a given grammar is a systematic process. Let's break it down into steps and calculate these sets for your grammar. Since the grammar is extensive, I'll start with the FIRST sets for each non-terminal and then move on to the FOLLOW sets.

FIRST Sets

The FIRST set of a non-terminal symbol is the set of terminals that appear at the beginning of some string derived from the non-terminal. An ε in the FIRST set indicates that the non-terminal can derive the empty string.

program: {def, ε, int, double, if, while, print, return, id, ε} - Begins with terminals found in fdecls, declarations, and statement_seq.

fdecls: {def, ε} - Begins with def or is empty.

fdec: {def} - Begins with def.

params: {int, double, ε} - Begins with type or is empty.

params': {,, ε} - Begins with , or is empty.

fname: {id} - Begins with id.

declarations: {int, double, ε} - Begins with type or is empty.

decl: {int, double} - Begins with type.

type: {int, double} - Is int or double.

varlist: {id} - Begins with var.

varlist': {,, ε} - Begins with , or is empty.

statement_seq: {if, id, while, print, return, ε} - Begins with terminals found in statement.

statement_seq': {;} - Begins with ;.

statement: {if, id, while, print, return, ε} - Begins with if, id (for assignment), while, print, return, or is empty.

statement': {fi, else} - Begins with fi or else.

expr: {id, (} - Begins with id or (.

expr': {+, -, ε} - Begins with +, -, or is empty.

term: {id, (} - Begins with id or (.

term': {*, /, %, ε} - Begins with *, /, %, or is empty.

factor: {id, (} - Begins with id or (.

factor': {(, ε} - Begins with ( or is empty.

exprseq: {id, (, ε} - Begins with id, (, or is empty.

exprseq': {,, ε} - Begins with , or is empty.

bexpr: {(, not, id} - Begins with (, not, or id.

bexpr': {or, ε} - Begins with or or is empty.

bterm: {(, not, id} - Begins with (, not, or id.

bterm': {and, ε} - Begins with and or is empty.

bfactor: {(, not, id} - Begins with (, not, or id.

comp: {<, >, ==, <=, >=, <>} - Is a comparison operator.

var: {id} - Begins with id.

var': {[, ε} - Begins with [ or is empty.

id: {letter} - Begins with letter.

number: {integer, double} - Is an integer or double.


Next, we'll calculate the FOLLOW sets.
------------------
FOLLOW Sets
The FOLLOW set of a non-terminal is the set of terminals that can appear immediately to the right of the non-terminal in some "sentential" form. The FOLLOW set helps in parsing, especially with predictive parsers, to decide which production to use.

program: {$} - The end of the input.

fdecls: {def, int, double, if, while, print, return, id} - Followed by the start of declarations or statement_seq.

fdec: {def, int, double, if, while, print, return, id} - Followed by another fdec in fdecls or the start of declarations or statement_seq.

params: {)} - Followed by ) in fdec.

params': {)} - Followed by ) in params.

fname: {(} - Followed by ( in fdec.

declarations: {def, int, double, if, while, print, return, id, fed, ;, fi, else} - Can be followed by more declarations, the start of statement_seq, or other terminals after declarations in different contexts.

decl: {def, int, double, if, while, print, return, id, fed, ;, fi, else} - Similar to declarations, it's followed by what can come after declarations.

type: {id} - Followed by var in decl and params.

varlist: {;} - Followed by ; in decl.

varlist': {;} - Followed by ; in varlist.

statement_seq: {fed, fi, else, od} - Followed by fed, fi, else, or od.

statement_seq': {fed, fi, else, od} - Similar to statement_seq, it follows the same terminals.

statement: {; , fed, fi, else, od} - Followed by ; in statement_seq', or other terminals after statement_seq.

statement': {fi, else} - Followed by the terminals after conditional statements.

expr: {), ;, or, and, ==, <, >, <=, >=, <>, ]} - Followed by these terminals in various contexts where expr is used.

expr': {), ;, or, and, ==, <, >, <=, >=, <>, ]} - Follows the same as expr.

term: {+, -, ), ;, or, and, ==, <, >, <=, >=, <>, ]} - Followed by these terminals in the contexts where term is used.

term': {+, -, ), ;, or, and, ==, <, >, <=, >=, <>, ]} - Follows the same as term.

factor: {* , /, %, +, -, ), ;, or, and, ==, <, >, <=, >=, <>, ]} - Followed by these terminals in the contexts where factor is used.

factor': {* , /, %, +, -, ), ;, or, and, ==, <, >, <=, >=, <>, ]} - Follows the same as factor.

exprseq: {)} - Followed by ) in function calls.

exprseq': {)} - Follows the same as exprseq.

bexpr: {), ;, fi, else, od} - Followed by these terminals in the contexts where bexpr is used.

bexpr': {), ;, fi, else, od} - Follows the same as bexpr.

bterm: {or, ), ;, fi, else, od} - Followed by these terminals in the contexts where bterm is used.

bterm': {or, ), ;, fi, else, od} - Follows the same as bterm.

bfactor: {and, or, ), ;, fi, else, od} - Followed by these terminals in the contexts where bfactor is used.

comp: {id, (} - Followed by expr in comparison operations.

var: {=, ], ;, or, and, ==, <, >, <=, >=, <>, +, -, *, /, %} - Followed by these terminals in various contexts where var is used.

var': {=, ], ;, or, and, ==, <, >, <=, >=, <>, +, -, *, /, %} - Follows the same as var.